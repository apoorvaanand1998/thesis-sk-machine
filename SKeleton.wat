(module
    (type $appNode
        (struct (field $left (mut anyref))
                (field $right (mut anyref))
                (field $name i32))) ;; name only for debugging, shall be removed later
    
    ;; Based on Marco's suggestion, refer to combinators and primitives with i31s too
    ;; i31s on the left node refer to prims and combs
    ;; i31s on the right node refer to constants
    ;; the explicit structs are the appNodes themselves

    (type $stack
        (array (mut (ref null $appNode))))

    (func $leftSpineLength (export "leftSpineLength")
     (param $an (ref null $appNode)) (result i32)
        ;; how many times can you keep going left?
        ;; compatible with createLAS (i.e. if you can go left once, it returns 2)
        (local $n i32)
        (i32.const 1)
        (local.set $n)

        (loop $keepLeft (result i32)
            (local.get $an)
            (struct.get $appNode $left)
            (ref.test (ref null $appNode))
            (if
            (then
                (local.get $n)
                (i32.const 1)
                (i32.add)
                (local.set $n) ;; increase n by 1

                (local.get $an)
                (struct.get $appNode $left)
                (ref.cast (ref null $appNode))
                (local.set $an)
                (br $keepLeft)
            ))
            (local.get $n)
        )
    )

    ;; LAS - Left Ancestor Stack
    (func $createLAS (export "createLAS")
     (param $an (ref null $appNode)) (param $treeHeight i32) (result (ref null $stack))
        ;; treeHeight here is always 1 more than the number of indices needed by the LAS
        (local $las (ref null $stack))
        (local $i i32) ;; stack variable

        (local.get $an)
        (ref.is_null)
        (if (result (ref null $stack))
            (then
                (ref.null $stack)
            )
            (else
                (ref.null $appNode)
                (local.get $treeHeight)
                (array.new $stack)
                (local.set $las)

                (i32.const 0)
                (local.set $i)
                
                (block $settingI
                    (loop $setI
                        (local.get $las)
                        (local.get $i)
                        (local.get $an)
                        (array.set $stack)
                        ;; set current node in the las, after which we check
                
                        (local.get $an)
                        (struct.get $appNode $left)
                        (ref.test (ref null $appNode))
                        (i32.eqz)
                        (br_if $settingI) ;; it was not an appNode end this loop

                        (local.get $i)
                        (i32.const 1)
                        (i32.add)
                        (local.set $i)
                        ;; ;; increment i
                        (local.get $an)
                        (struct.get $appNode $left)
                        (ref.cast (ref null $appNode)) 
                        (local.set $an)
                        ;; set curr to left of curr
                        (br $setI)
                        ;; loop
                    )
                )
                (local.get $las)
            )
        )
    )

    ;; supported combinators and primitives
    ;; S, K, Y, C, B, I, cond, true, false, plus, minus, times, divide, intEq, intGt, intLt, intGte, intLte, and, or, not
    
    (func $step (export "step") 
     (param $las (ref null $stack)) (param $n i32) (result i32)
     ;; function returns the next index of the las we should work with
     ;; n is the index of the las we are currently working with
        (local $x anyref)
        (local $y anyref)
        (local $z anyref)
        (local $w anyref)
        (local $v anyref)
        (local $temp (ref null $appNode))
        (local $r i32)
        (local $ascii i32) ;; i8 can work here too
        ;; get the nth element of the las
        (local.get $las)
        (local.get $n)
        (array.get $stack)
        ;; take the left and check what kind of combinator it is
        (struct.get $appNode $left)
        (ref.cast i31ref)
        (i31.get_s)
        (local.set $ascii)
        ;; the nth argument of the combinator will be the right subtree 
        ;; of the object n places behind it on the stack

        ;; do a case split here based on the combinator we have
        ;; load args into locals
        ;; use locals to create new struct
        ;; connect newly created struct to the previous structs
        ;; return new index of las to work with (and also modify las)

        (block $combCase
;; S Combinator Start
(local.get $ascii)
(i32.const 0)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $x)
(local.get $z)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $y)
(local.get $z)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $right)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(i32.const 1)
(i32.add)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $left)
(ref.cast (ref null $appNode))
(array.set $stack)
(local.get $n)
(i32.const 2)
(i32.sub)
(i32.const 1)
(i32.add)
(local.set $r)
(br $combCase)))
;; S Combinator End

;; K Combinator Start
(local.get $ascii)
(i32.const 1)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(i32.const 2)(ref.i31)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(local.get $x)
(struct.set $appNode $right)
(local.get $n)
(i32.const 1)
(i32.sub)
(local.set $r)
(br $combCase)))
;; K Combinator End

;; I Combinator Start
(local.get $ascii)
(i32.const 2)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(local.get $x)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(local.get $y)
(struct.set $appNode $right)
(local.get $n)
(i32.const 1)
(i32.sub)
(local.set $r)
(br $combCase)))
;; I Combinator End

;; B Combinator Start
(local.get $ascii)
(i32.const 3)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $x)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $y)
(local.get $z)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $right)
(local.get $n)
(i32.const 2)
(i32.sub)
(local.set $r)
(br $combCase)))
;; B Combinator End

;; C Combinator Start
(local.get $ascii)
(i32.const 4)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $x)
(local.get $z)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $y)
(struct.set $appNode $right)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(i32.const 1)
(i32.add)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $left)
(ref.cast (ref null $appNode))
(array.set $stack)
(local.get $n)
(i32.const 2)
(i32.sub)
(i32.const 1)
(i32.add)
(local.set $r)
(br $combCase)))
;; C Combinator End

;; A Combinator Start
(local.get $ascii)
(i32.const 5)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(i32.const 2)(ref.i31)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(local.get $y)
(struct.set $appNode $right)
(local.get $n)
(i32.const 1)
(i32.sub)
(local.set $r)
(br $combCase)))
;; A Combinator End

;; Y Combinator Start
(local.get $ascii)
(i32.const 6)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(array.get $stack)
(local.get $x)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(array.get $stack)
(local.set $y)
(local.get $las)
(local.get $n)
(array.get $stack)
(local.get $y)
(struct.set $appNode $right)
(local.get $n)
(local.set $r)
(br $combCase)))
;; Y Combinator End

;; SS Combinator Start
(local.get $ascii)
(i32.const 7)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $w)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(local.get $x)
(local.get $x)
(local.get $y)
(i32.const 42)
(struct.new $appNode)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(local.get $z)
(local.get $w)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $right)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(i32.const 1)
(i32.add)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(struct.get $appNode $left)
(ref.cast (ref null $appNode))
(array.set $stack)
(local.get $n)
(i32.const 3)
(i32.sub)
(i32.const 1)
(i32.add)
(local.set $r)
(br $combCase)))
;; SS Combinator End

;; BB Combinator Start
(local.get $ascii)
(i32.const 8)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $w)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(local.get $x)
(local.get $y)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(local.get $z)
(local.get $w)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $right)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(i32.const 1)
(i32.add)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(struct.get $appNode $left)
(ref.cast (ref null $appNode))
(array.set $stack)
(local.get $n)
(i32.const 3)
(i32.sub)
(i32.const 1)
(i32.add)
(local.set $r)
(br $combCase)))
;; BB Combinator End

;; CC Combinator Start
(local.get $ascii)
(i32.const 9)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $w)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(local.get $x)
(local.get $y)
(local.get $w)
(i32.const 42)
(struct.new $appNode)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(local.get $z)
(struct.set $appNode $right)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(i32.const 1)
(i32.add)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(struct.get $appNode $left)
(ref.cast (ref null $appNode))
(array.set $stack)
(local.get $n)
(i32.const 3)
(i32.sub)
(i32.const 1)
(i32.add)
(local.set $r)
(br $combCase)))
;; CC Combinator End

;; P Combinator Start
(local.get $ascii)
(i32.const 10)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $z)
(local.get $x)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $y)
(struct.set $appNode $right)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(i32.const 1)
(i32.add)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $left)
(ref.cast (ref null $appNode))
(array.set $stack)
(local.get $n)
(i32.const 2)
(i32.sub)
(i32.const 1)
(i32.add)
(local.set $r)
(br $combCase)))
;; P Combinator End

;; R Combinator Start
(local.get $ascii)
(i32.const 11)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $y)
(local.get $z)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $x)
(struct.set $appNode $right)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(i32.const 1)
(i32.add)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $left)
(ref.cast (ref null $appNode))
(array.set $stack)
(local.get $n)
(i32.const 2)
(i32.sub)
(i32.const 1)
(i32.add)
(local.set $r)
(br $combCase)))
;; R Combinator End

;; O Combinator Start
(local.get $ascii)
(i32.const 12)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $w)
(local.get $x)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $y)
(struct.set $appNode $right)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(i32.const 1)
(i32.add)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $left)
(ref.cast (ref null $appNode))
(array.set $stack)
(local.get $n)
(i32.const 2)
(i32.sub)
(i32.const 1)
(i32.add)
(local.set $r)
(br $combCase)))
;; O Combinator End

;; U Combinator Start
(local.get $ascii)
(i32.const 13)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(local.get $y)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(local.get $x)
(struct.set $appNode $right)
(local.get $n)
(i32.const 1)
(i32.sub)
(local.set $r)
(br $combCase)))
;; U Combinator End

;; Z Combinator Start
(local.get $ascii)
(i32.const 14)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $x)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $y)
(struct.set $appNode $right)
(local.get $n)
(i32.const 2)
(i32.sub)
(local.set $r)
(br $combCase)))
;; Z Combinator End

;; K2 Combinator Start
(local.get $ascii)
(i32.const 15)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(i32.const 2)(ref.i31)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(local.get $x)
(struct.set $appNode $right)
(local.get $n)
(i32.const 2)
(i32.sub)
(local.set $r)
(br $combCase)))
;; K2 Combinator End

;; K3 Combinator Start
(local.get $ascii)
(i32.const 16)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $w)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(i32.const 2)(ref.i31)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(local.get $x)
(struct.set $appNode $right)
(local.get $n)
(i32.const 3)
(i32.sub)
(local.set $r)
(br $combCase)))
;; K3 Combinator End

;; K4 Combinator Start
(local.get $ascii)
(i32.const 17)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $w)
(local.get $las)
(local.get $n)
(i32.const 4)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $v)
(local.get $las)
(local.get $n)
(i32.const 4)
(i32.sub)
(array.get $stack)
(i32.const 2)(ref.i31)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 4)
(i32.sub)
(array.get $stack)
(local.get $x)
(struct.set $appNode $right)
(local.get $n)
(i32.const 4)
(i32.sub)
(local.set $r)
(br $combCase)))
;; K4 Combinator End

;; CCB Combinator Start
(local.get $ascii)
(i32.const 18)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 2)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $z)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $w)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(local.get $x)
(local.get $z)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(local.get $y)
(local.get $w)
(i32.const 42)
(struct.new $appNode)
(struct.set $appNode $right)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(i32.const 1)
(i32.add)
(local.get $las)
(local.get $n)
(i32.const 3)
(i32.sub)
(array.get $stack)
(struct.get $appNode $left)
(ref.cast (ref null $appNode))
(array.set $stack)
(local.get $n)
(i32.const 3)
(i32.sub)
(i32.const 1)
(i32.add)
(local.set $r)
(br $combCase)))
;; CCB Combinator End

;; ADD Combinator Start
(local.get $ascii)
(i32.const 19)
(i32.eq)
(if (then
(local.get $las)
(local.get $n)
(array.get $stack)
(struct.get $appNode $right)
(local.set $x)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(struct.get $appNode $right)
(local.set $y)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(i32.const 2)(ref.i31)
(struct.set $appNode $left)
(local.get $las)
(local.get $n)
(i32.const 1)
(i32.sub)
(array.get $stack)
(local.get $x)
(call $i31OrReduce)
(local.get $y)
(call $i31OrReduce)
(i32.add)
(ref.i31)
(struct.set $appNode $right)
(local.get $n)
(i32.const 1)
(i32.sub)
(local.set $r)
(br $combCase)))
;; ADD Combinator End
        )
    (local.get $r)
    )

    (func $i31OrReduce (export "i31OrReduce")
     ;; looks at the anyref given to it and if it's an i31, converts it to i32
     ;; otherwise assumes it is an appNode and calls reduce on it
     (param $x anyref) (result i32)
        (local $temp (ref null $appNode))
        (local $n i32)

        (local.get $x)
        (ref.test i31ref)
        (if (result i32)
        (then
            (local.get $x)
            (ref.cast i31ref)
            (i31.get_s)
        )
        (else
            (local.get $x)
            (ref.cast (ref null $appNode))
            (local.tee $temp)
            (call $leftSpineLength)
            (local.set $n)
            (local.get $temp)
            (local.get $n)
            (call $reduce)
        )
        )
    )

    (func $reduce (export "reduce")
        (param $an (ref null $appNode)) (param $treeHeight i32) (result i32) 
        ;; I am going to support a result type of only i32 for now, would work with bools as well
        ;; later on, perhaps f64 is a better type to encompass everything?
        ;; treeHeight = max index of LAS + 1
        (local $las (ref null $stack))
        (local $curr (ref null $appNode))
        (local $result i32)

        (local.get $an)
        (local.get $treeHeight)
        (call $createLAS)
        (local.set $las)
        
        ;; an expression is fully reduced when step returns 0
        ;; this would mean there is nothing to do, except look at the 
        ;; hopefully I combinator on the left and return the i32 on the right as result
        ;; ah no, K x y at the height of 1 is also a fully reduced expression
        ;; but what I can do there is to reduce it to (I x) instead of just x
        ;; same thing when it comes to other primOps
        ;; so that's what Turner meant with the whole (I x) thing!

        ;; now reduce treeHeight to go from 1-indexed to 0-indexed
        (local.get $treeHeight)
        (i32.const 1)
        (i32.sub)
        (local.set $treeHeight)
        
        (loop $untilStepFully
            (local.get $treeHeight)
            (i32.eqz)
            (if
            (then
                (local.get $las)
                (i32.const 0)
                (array.get $stack)
                (local.tee $curr)
                (struct.get $appNode $left)
                ;; (ref.cast (ref null $comb))
                ;; (struct.get $comb $asciiTag)
                (ref.cast i31ref)
                (i31.get_s)
                (i32.const 2)
                (i32.eq)
                ;; checking if it is an I

                (if
                (then
                    (local.get $curr)
                    (struct.get $appNode $right)
                    (ref.cast i31ref)
                    (i31.get_s)
                    (local.set $result)
                )
                (else
                    (unreachable)
                    ;; why the FUCK is it not an I?
                )
                )
            )
            (else
                (local.get $las)
                (local.get $treeHeight)
                (call $step) ;; this returns 0 if we are done, otherwise redo this with newly set treeHeight
                (local.set $treeHeight)
                (br $untilStepFully)
            )
            )
        )
        (local.get $result)
    )

    (func $main (export "main") (result i32)
        (local $an (ref null $appNode))
        (local $n i32)
        (i32.const 0) ;; S
        (ref.i31)
        (i32.const 1) ;; K
        (ref.i31)
        (i32.const 0) ;; name 0
        (struct.new $appNode)
        (i32.const 1) ;; K
        (ref.i31) 
        (i32.const 1) ;; name 1
        (struct.new $appNode)
        (i32.const 42) ;; constant 42
        (ref.i31)
        (i32.const 2) ;; name 2
        (struct.new $appNode)
        (local.tee $an)
        (call $leftSpineLength)
        (local.set $n)
        (local.get $an)
        (local.get $n)
        (call $reduce)
    )
)